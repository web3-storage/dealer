import * as Sentry from '@sentry/serverless'
import { Config } from 'sst/node/config'
import { APIGatewayProxyEventV2 } from 'aws-lambda'

import * as Server from '@ucanto/server'
import * as CAR from '@ucanto/transport/car'
import { API } from '@ucanto/core'

import { connect as ucanLogConnect } from '@spade-proxy/core/ucan-log'
import { createOfferStore } from '@spade-proxy/core/buckets/offer-store'
import { createAggregateStore } from '@spade-proxy/core/tables/aggregate-store'
import { createArrangedOfferStore } from '@spade-proxy/core/tables/arranged-offer-store'
import { createUcantoServer, getServiceSigner } from '@spade-proxy/core/service'

import { mustGetEnv } from '../utils'

Sentry.AWSLambda.init({
  environment: process.env.SST_STAGE,
  dsn: process.env.SENTRY_DSN,
  tracesSampleRate: 1.0,
})
const AWS_REGION = process.env.AWS_REGION || 'us-west-2'

export async function ucanInvocationRouter(request: APIGatewayProxyEventV2) {
  const {
    offerBucketName,
    arrangedOfferTableName,
    spadeProxyDid,
    ucanLogUrl
  } = getLambdaEnv()

  if (!spadeProxyDid) {
    return {
      statusCode: 500,
    }
  } else if (request.body === undefined) {
    return {
      statusCode: 400,
    }
  }

  const { PRIVATE_KEY, UCAN_LOG_BASIC_AUTH } = Config

  const ucanLog = ucanLogConnect({
    url: new URL(ucanLogUrl || ''),
    auth: UCAN_LOG_BASIC_AUTH
  })
  const serviceSigner = getServiceSigner({ SPADE_PROXY_DID: spadeProxyDid, PRIVATE_KEY })
  const arrangedOfferStore = createArrangedOfferStore(AWS_REGION, arrangedOfferTableName)

  const server = createUcantoServer(serviceSigner, {
    aggregateStore: createAggregateStore(),
    offerStore: createOfferStore(AWS_REGION, offerBucketName, arrangedOfferStore),
    arrangedOfferStore
  }, {
    catch: (/** @type {string | Error} */ err) => {
      console.warn(err)
      Sentry.AWSLambda.captureException(err)
    },
  })

  const payload = fromLambdaRequest(request)
  const result = server.codec.accept(payload)
  // if we can not select a codec we respond with error.
  if (result.error) {
    return toLambdaResponse({
      status: result.error.status,
      headers: result.error.headers || {},
      body: Buffer.from(result.error.message || ''),
    })
  }

  const { encoder, decoder } = result.ok
  /** @type {API.AgentMessage} */
  const message = await decoder.decode(payload)

  // We block until we can log the UCAN invocation if this fails we return a 500
  // to the client. That is because in the future we expect that invocations will
  // be written to a queue first and then processed asynchronously, so if we
  // fail to enqueue the invocation we should fail the request.
  await ucanLog.log(CAR.request.encode(message))

  // Execute invocations
  // @ts-expect-error message with unknown...
  const outgoing = await Server.execute(message, server)
  const response = await encoder.encode(outgoing)

  // Send ucan receipt
  await ucanLog.log(CAR.response.encode(outgoing))

  return toLambdaResponse(response)
}

export const handler = Sentry.AWSLambda.wrapHandler(ucanInvocationRouter)

export function toLambdaResponse({ status = 200, headers, body }: API.HTTPResponse) {
  return {
    statusCode: status,
    headers,
    body: Buffer.from(body).toString('base64'),
    isBase64Encoded: true,
  }
}

export const fromLambdaRequest = (request: APIGatewayProxyEventV2) => ({
  headers: /** @type {Record<string, string>} */ (request.headers),
  body: Buffer.from(request.body || '', 'base64'),
} as API.HTTPRequest)

function getLambdaEnv () {
  return {
    arrangedOfferTableName: mustGetEnv('ARRANGED_OFFER_TABLE_NAME'),
    offerBucketName: mustGetEnv('OFFER_BUCKET_NAME'),
    spadeProxyDid: mustGetEnv('SPADE_PROXY_DID'),
    ucanLogUrl: mustGetEnv('UCAN_LOG_URL')
  }
}

// would be generated by sst, but requires `sst build` to be run, which calls out to aws; not great for CI
declare module 'sst/node/config' {
  export interface SecretResources {
    PRIVATE_KEY: {
      value: string
    },
    UCAN_LOG_BASIC_AUTH: {
      value: string
    }
  }
}
