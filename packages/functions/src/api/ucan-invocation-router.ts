import * as Sentry from '@sentry/serverless'
import { Table } from 'sst/node/table'
import { Config } from 'sst/node/config'
import { APIGatewayProxyEventV2 } from 'aws-lambda'

import * as Server from '@ucanto/server'
import * as CAR from '@ucanto/transport/car'
import { API } from '@ucanto/core'

import { connect as ucanLogConnect } from '@dealer/core/src/ucan-log'
import { createQueueClient } from '@dealer/core/src/queue/client'
import { createBucketStoreClient } from '@dealer/core/src/store/bucket-client'
import { createTableStoreClient } from '@dealer/core/src/store/table-client'
import { createUcantoServer, getServiceSigner } from '@dealer/core/src/service'
import { encode as offerEncode, decode as offerDecode } from '@dealer/core/src/data/offer'
import { encode as dealEncode, decode as dealDecode } from '@dealer/core/src/data/deal'

import { mustGetEnv } from '../utils'

Sentry.AWSLambda.init({
  environment: process.env.SST_STAGE,
  dsn: process.env.SENTRY_DSN,
  tracesSampleRate: 1.0,
})

export async function ucanInvocationRouter(request: APIGatewayProxyEventV2) {
  const {
    did,
    ucanLogUrl,
    dealTableName,
    dealTableRegion,
    offerBucketName,
    offerBucketRegion,
    dealerQueueUrl,
    dealerQueueRegion,
  } = getLambdaEnv()

  if (!did) {
    return {
      statusCode: 500,
    }
  } else if (request.body === undefined) {
    return {
      statusCode: 400,
    }
  }

  const { PRIVATE_KEY: privateKey, UCAN_LOG_BASIC_AUTH } = Config

  const ucanLog = ucanLogConnect({
    url: new URL(ucanLogUrl || ''),
    auth: UCAN_LOG_BASIC_AUTH
  })

  // context
  const serviceSigner = getServiceSigner({ did, privateKey })
  const offerStore = createBucketStoreClient({
    region: offerBucketRegion
  }, {
    name: offerBucketName,
    encodeRecord: offerEncode.record,
    encodeKey: offerEncode.key,
    decodeRecord: offerDecode.record,
  })
  const dealStore = createTableStoreClient({
    region: dealTableRegion
  }, {
    tableName: dealTableName,
    encodeRecord: dealEncode.record,
    encodeKey: dealEncode.key,
    decodeRecord: dealDecode.record
  })
  const addQueue = createQueueClient({
    region: dealerQueueRegion
  }, {
    queueUrl: dealerQueueUrl,
    encodeMessage: offerEncode.message,
    encodeKey: (deal) => {
      const key = offerEncode.key(deal)

      // Encode key with bucket identifier
      return `s3://${offerBucketName}/${key}`
    },
    store: offerStore
  })

  const server = createUcantoServer(serviceSigner, {
    dealStore,
    addQueue,
    id: serviceSigner
  }, {
    catch: (/** @type {string | Error} */ err) => {
      console.warn(err)
      Sentry.AWSLambda.captureException(err)
    },
  })

  const payload = fromLambdaRequest(request)
  const result = server.codec.accept(payload)
  // if we can not select a codec we respond with error.
  if (result.error) {
    return toLambdaResponse({
      status: result.error.status,
      headers: result.error.headers || {},
      body: Buffer.from(result.error.message || ''),
    })
  }

  const { encoder, decoder } = result.ok
  /** @type {API.AgentMessage} */
  const message = await decoder.decode(payload)

  // We block until we can log the UCAN invocation if this fails we return a 500
  // to the client. That is because in the future we expect that invocations will
  // be written to a queue first and then processed asynchronously, so if we
  // fail to enqueue the invocation we should fail the request.
  await ucanLog.log(CAR.request.encode(message))

  // Execute invocations
  // @ts-expect-error message with unknown...
  const outgoing = await Server.execute(message, server)
  const response = await encoder.encode(outgoing)

  // Send ucan receipt
  await ucanLog.log(CAR.response.encode(outgoing))

  return toLambdaResponse(response)
}

export const handler = Sentry.AWSLambda.wrapHandler(ucanInvocationRouter)

function getLambdaEnv () {
  return {
    did: mustGetEnv('DID'),
    ucanLogUrl: mustGetEnv('UCAN_LOG_URL'),
    dealTableName: Table['deal-store'].tableName,
    dealTableRegion: mustGetEnv('AWS_REGION'),
    offerBucketName: mustGetEnv('OFFER_STORE_BUCKET_NAME'),
    offerBucketRegion: mustGetEnv('AWS_REGION'),
    dealerQueueUrl: mustGetEnv('DEALER_QUEUE_URL'),
    dealerQueueRegion: mustGetEnv('DEALER_QUEUE_REGION')
  }
}

export function toLambdaResponse({ status = 200, headers, body }: API.HTTPResponse) {
  return {
    statusCode: status,
    headers,
    body: Buffer.from(body).toString('base64'),
    isBase64Encoded: true,
  }
}

export const fromLambdaRequest = (request: APIGatewayProxyEventV2) => ({
  headers: /** @type {Record<string, string>} */ (request.headers),
  body: Buffer.from(request.body || '', 'base64'),
} as API.HTTPRequest)

// would be generated by sst, but requires `sst build` to be run, which calls out to aws; not great for CI
declare module 'sst/node/config' {
  export interface SecretResources {
    PRIVATE_KEY: {
      value: string
    },
    UCAN_LOG_BASIC_AUTH: {
      value: string
    }
  }
}

declare module 'sst/node/table' {
  export interface TableResources {
    'deal-store': {
      tableName: string;
    };
  }
}
