import * as Sentry from '@sentry/serverless'
import { Config } from 'sst/node/config'
import { unmarshall } from '@aws-sdk/util-dynamodb'
import { DynamoDBStreamEvent } from 'aws-lambda'

import { encode as offerEncode, decode as offerDecode } from '@dealer/core/src/data/offer'
import { decode as dealDecode, EncodedDeal, Status } from '@spade-proxy/core/data/deal'
import { aggregateAccept } from '@dealer/core/src/workflow/aggregate-accept'
import { getServiceSigner, getServiceConnection } from '@spade-proxy/core/service'
import { createBucketStoreClient } from '@dealer/core/src/store/bucket-client'

import { mustGetEnv } from '../utils'

Sentry.AWSLambda.init({
  environment: process.env.SST_STAGE,
  dsn: process.env.SENTRY_DSN,
  tracesSampleRate: 1.0,
})

export async function main(event: DynamoDBStreamEvent) {
  // Construct context
  const {
    offerBucketName,
    offerBucketRegion,
    dealerDid,
    dealerUrl,
    privateKey
  } = getLambdaEnv()

  // Get deal ready for aggregate/accept
  const records = parseDynamoDbEvent(event)
  if (records.length > 1) {
    throw new Error('Should only receive one deal to accept')
  }
  // @ts-expect-error can't figure out type of new
  const dealRecord = unmarshall(records[0].new) as EncodedDeal
  const deal = dealDecode.record(dealRecord)
  if (deal.stat === Status.Offered) {
    throw new Error(`deal for aggregate ${deal.aggregate.link.toString()} is still in Offered state`)
  }

  const issuer = getServiceSigner({
    privateKey
  })
  const dealerServiceConnection = getServiceConnection({
    did: dealerDid,
    url: dealerUrl
  })
  const offerStore = createBucketStoreClient({
    region: offerBucketRegion
  }, {
    name: offerBucketName,
    encodeRecord: offerEncode.record,
    encodeKey: offerEncode.key,
    decodeRecord: offerDecode.record,
  })

  // Trigger workflow
  const { ok, error } = await aggregateAccept({
    deal,
    dealerServiceConnection,
    dealerInvocationConfig: {
      issuer,
      audience: dealerServiceConnection.id,
      with: issuer.did(),
    },
    offerStore
  })

  if (error) {
    console.error(error)
    return {
      statusCode: 500,
      body: error.message || 'failed to invoke `aggregate/accept'
    }
  }

  return {
    statusCode: 200,
    body: ok
  }
}

/**
 * Get Env validating it is set.
 */
function getLambdaEnv () {
  const { PRIVATE_KEY: privateKey } = Config
  return {
    offerBucketName: mustGetEnv('OFFER_STORE_BUCKET_NAME'),
    offerBucketRegion: mustGetEnv('AWS_REGION'),
    dealerDid: mustGetEnv('DID'),
    dealerUrl: mustGetEnv('URL'),
    privateKey
  }
}

function parseDynamoDbEvent (event: DynamoDBStreamEvent) {
  return event.Records.map(r => ({
    new: r.dynamodb?.NewImage,
    old: r.dynamodb?.OldImage
  }))
}

// would be generated by sst, but requires `sst build` to be run, which calls out to aws; not great for CI
declare module 'sst/node/config' {
  export interface SecretResources {
    PRIVATE_KEY: {
      value: string
    }
  }
}
